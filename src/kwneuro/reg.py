from __future__ import annotations

import shutil
from dataclasses import dataclass
from pathlib import Path

import ants

from kwneuro.resource import InMemoryVolumeResource, VolumeResource
from kwneuro.util import PathLike, normalize_path


@dataclass()
class TransformResource:
    """A wrapper for ANTs registration results that simplifies viewing and
    applying transforms. While the underlying transform files are always
    stored on-disk, they remain in a temporary directory until explicitly
    persisted via the save() method."""

    # Raw paths to ants output files
    _ants_fwd_paths: list[str]
    _ants_inv_paths: list[str]

    # Store the actual objects if they are already loaded
    _matrices: list[ants.ANTsTransform] | None = None
    _warps: list[InMemoryVolumeResource] | None = None

    @property
    def matrices(self) -> list[ants.ANTsTransform]:
        """Returns the affine transform if it exists."""
        if self._matrices is None:
            # Find the .mat file in paths and load it
            mat_paths = [p for p in self._ants_fwd_paths if p.endswith(".mat")]
            self._matrices = [ants.core.read_transform(p) for p in mat_paths]
        return self._matrices

    @property
    def warp_fields(self) -> list[InMemoryVolumeResource]:
        """Returns the non-linear displacement field if it exists."""

        if self._warps is None:
            # Get all warp files (typically .nii)
            warp_paths = [p for p in self._ants_fwd_paths if ".nii" in p]

            warp_volumes = []
            for p in warp_paths:
                ants_img = ants.image_read(p)
                warp_volumes.append(InMemoryVolumeResource.from_ants_image(ants_img))
            self._warps = warp_volumes
        return self._warps

    @staticmethod
    def initialize_from_ants(ants_result: dict[str, list[str]]) -> TransformResource:
        """Initializes a TransformResource from an ANTs registration result by
        wrapping references to the temporary transform files generated by ANTs."""

        ants_fwdtransforms = ants_result["fwdtransforms"]

        return TransformResource(
            _ants_fwd_paths=ants_fwdtransforms,
            _ants_inv_paths=ants_result["invtransforms"],
        )

    def apply(
        self,
        fixed: VolumeResource,
        moving: VolumeResource,
        invert: bool = False,
        interpolation: str = "linear",
    ) -> InMemoryVolumeResource:
        """Wrapper around ants.apply_transforms using this result."""

        fixed = fixed.load()
        moving = moving.load()

        ants_fixed = fixed.to_ants_image()
        ants_moving = moving.to_ants_image()

        transforms = self._ants_inv_paths if invert else self._ants_fwd_paths

        # Ants does not pre-invert the .mat files
        # so we need to explicitly specify that it needs to be inverted.
        # This is done in ANTs by default when the inv transform list is used but
        # we specify it here for clarity.
        if invert:
            whichtoinvert = [p.endswith(".mat") for p in transforms]
        else:
            whichtoinvert = [False] * len(transforms)

        warpedmovout = ants.apply_transforms(
            fixed=ants_fixed,
            moving=ants_moving,
            transformlist=transforms,
            whichtoinvert=whichtoinvert,
            interpolator=interpolation,
        )

        return InMemoryVolumeResource.from_ants_image(warpedmovout)

    def save(self, output_dir: PathLike) -> TransformResource:
        """Copies the underlying ANTs transformation files to a permanent directory
        and returns a new TransformResource pointing to the saved locations"""

        path = normalize_path(output_dir)
        path.mkdir(parents=True, exist_ok=True)

        # Files get saved with default temp names from ANTs
        copied_files = {}
        saved_fwd_paths = []
        for p in self._ants_fwd_paths:
            if p not in copied_files:
                dest = path / Path(p).name
                shutil.copy(p, dest)
                copied_files[p] = dest
            saved_fwd_paths.append(str(copied_files[p]))

        saved_inv_paths = []
        for p in self._ants_inv_paths:
            if p not in copied_files:
                dest = path / Path(p).name
                shutil.copy(p, dest)
                copied_files[p] = dest
            saved_inv_paths.append(str(copied_files[p]))

        return TransformResource(
            _ants_fwd_paths=saved_fwd_paths,
            _ants_inv_paths=saved_inv_paths,
        )


def register_volumes(
    fixed: VolumeResource,
    moving: VolumeResource,
    type_of_transform: str = "SyN",
    mask: VolumeResource | None = None,
    moving_mask: VolumeResource | None = None,
) -> tuple[InMemoryVolumeResource, TransformResource]:
    """
    Registers a moving volume to a fixed reference volume using ANTs.

    Args:
        fixed: The reference volume.
        moving: The volume to be warped.
        type_of_transform: The transformation model (e.g., "SyN", "Rigid"). The full list of
            supported transforms can be found in the ANTs documentation.
        mask: Optional mask for the fixed image space.
        moving_mask: Optional mask for the moving image space.

    Returns:
        A tuple containing the registered volume and the transform object.

    """
    fixed = fixed.load()
    moving = moving.load()

    # Check input volume
    if fixed.get_array().ndim > 3 or moving.get_array().ndim > 3:
        error_message = "Input volume dimensions must be 2D or 3D."
        raise ValueError(error_message)

    ants_fixed = fixed.to_ants_image()
    ants_moving = moving.to_ants_image()

    # Convert masks to ants images if provided
    ants_mask = mask.load().to_ants_image() if mask is not None else None
    ants_moving_mask = (
        moving_mask.load().to_ants_image() if moving_mask is not None else None
    )

    # Check that the mask dimensions match the fixed/moving images
    if ants_mask is not None and (ants_mask.shape != ants_fixed.shape):
        error_message = "Fixed mask dimensions do not match fixed image dimensions."
        raise ValueError(error_message)
    if ants_moving_mask is not None and (ants_moving_mask.shape != ants_moving.shape):
        error_message = "Moving mask dimensions do not match moving image dimensions."
        raise ValueError(error_message)

    ants_result = ants.registration(
        fixed=ants_fixed,
        moving=ants_moving,
        mask=ants_mask,
        movingmask=ants_moving_mask,
        type_of_transform=type_of_transform,
    )

    warpedmovout = InMemoryVolumeResource.from_ants_image(ants_result["warpedmovout"])

    transform = TransformResource.initialize_from_ants(ants_result)

    return (warpedmovout, transform)
